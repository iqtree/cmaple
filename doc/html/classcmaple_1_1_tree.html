<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMAPLE: cmaple::Tree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CMAPLE<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">CMaple phylogenetic software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cmaple</b></li><li class="navelem"><a class="el" href="classcmaple_1_1_tree.html">Tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcmaple_1_1_tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cmaple::Tree Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tree_8h_source.html">tree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a39bd3bfce400c9222e8b77c584d26d43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43">TreeSearchType</a> { <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43a782a94a0336018d3a43f5e71e76e0bc6">FAST_TREE_SEARCH</a>
, <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43ad597e07c0182b56b0bc3d67b8fdaf0c1">NORMAL_TREE_SEARCH</a>
, <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43ae452d25b3b1a6060c8f156d0a35566d2">MORE_ACCURATE_TREE_SEARCH</a>
, <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43a5c358c56b2d42131093b6b5386d1d8f5">UNKNOWN_TREE_SEARCH</a>
 }</td></tr>
<tr class="separator:a39bd3bfce400c9222e8b77c584d26d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750c5e7c53559fbcc421020bad665376"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376">TreeType</a> { <a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376aed3efab1c9a9364074e767a772c132da">BIN_TREE</a>
, <a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376a0156cc734ae126b57d1a6ceeb22bd9e9">MUL_TREE</a>
, <a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376af211a6a48af98121a51064677ec6d851">UNKNOWN_TREE</a>
 }</td></tr>
<tr class="separator:a750c5e7c53559fbcc421020bad665376"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac8b9c0385a290c3d535434ae843338ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#ac8b9c0385a290c3d535434ae843338ce">Tree</a> (<a class="el" href="classcmaple_1_1_alignment.html">Alignment</a> *aln, <a class="el" href="classcmaple_1_1_model.html">Model</a> *model, std::istream &amp;tree_stream, const bool fixed_blengths=false, std::unique_ptr&lt; cmaple::Params &gt; &amp;&amp;params=nullptr)</td></tr>
<tr class="memdesc:ac8b9c0385a290c3d535434ae843338ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a stream of a (bifurcating or multifurcating) tree (with/without branch lengths in NEWICK format), which may or may not contain all taxa in the alignment. <a class="el" href="classcmaple_1_1_model.html">Model</a> parameters (if not fixed) will be estimated according to the input tree and the alignment.  <br /></td></tr>
<tr class="separator:ac8b9c0385a290c3d535434ae843338ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71b78fbf62c78e5630ac76f3fc319dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#af71b78fbf62c78e5630ac76f3fc319dc">Tree</a> (<a class="el" href="classcmaple_1_1_alignment.html">Alignment</a> *aln, <a class="el" href="classcmaple_1_1_model.html">Model</a> *model, const std::string &amp;tree_filename=&quot;&quot;, const bool fixed_blengths=false, std::unique_ptr&lt; cmaple::Params &gt; &amp;&amp;params=nullptr)</td></tr>
<tr class="memdesc:af71b78fbf62c78e5630ac76f3fc319dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an optional (bifurcating or multifurcating) tree (with/without branch lengths in NEWICK format), which may or may not contain all taxa in the alignment. If users specify an input tree, model parameters (if not fixed) will be estimated according to that tree and the alignment.  <br /></td></tr>
<tr class="separator:af71b78fbf62c78e5630ac76f3fc319dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05ee284fd0e9edba07708ec914eb045"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#ae05ee284fd0e9edba07708ec914eb045">~Tree</a> ()</td></tr>
<tr class="separator:ae05ee284fd0e9edba07708ec914eb045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c288e5a4ae4277615cb24268dca2f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#af8c288e5a4ae4277615cb24268dca2f2">load</a> (std::istream &amp;tree_stream, const bool fixed_blengths=false)</td></tr>
<tr class="memdesc:af8c288e5a4ae4277615cb24268dca2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a tree from a stream of a (bifurcating or multifurcating) tree (with/without branch lengths) in NEWICK format, which may or may not contain all taxa in the alignment. <a class="el" href="classcmaple_1_1_model.html">Model</a> parameters (if not fixed) will be estimated according to the input tree and the alignment.  <br /></td></tr>
<tr class="separator:af8c288e5a4ae4277615cb24268dca2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2479eb26d00469ee1040dd9bee18e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a1b2479eb26d00469ee1040dd9bee18e5">load</a> (const std::string &amp;tree_filename, const bool fixed_blengths=false)</td></tr>
<tr class="memdesc:a1b2479eb26d00469ee1040dd9bee18e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a tree from a (bifurcating or multifurcating) tree (with/without branch lengths) in NEWICK format, which may or may not contain all taxa in the alignment. <a class="el" href="classcmaple_1_1_model.html">Model</a> parameters (if not fixed) will be estimated according to the input tree and the alignment.  <br /></td></tr>
<tr class="separator:a1b2479eb26d00469ee1040dd9bee18e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab932b3742c6e18d51554f72432c18151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#ab932b3742c6e18d51554f72432c18151">changeAln</a> (<a class="el" href="classcmaple_1_1_alignment.html">Alignment</a> *aln)</td></tr>
<tr class="memdesc:ab932b3742c6e18d51554f72432c18151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the alignment.  <br /></td></tr>
<tr class="separator:ab932b3742c6e18d51554f72432c18151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f982f45f38226193cd584bbe7e93ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#aa4f982f45f38226193cd584bbe7e93ef">changeModel</a> (<a class="el" href="classcmaple_1_1_model.html">Model</a> *model)</td></tr>
<tr class="memdesc:aa4f982f45f38226193cd584bbe7e93ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the substitution model.  <br /></td></tr>
<tr class="separator:aa4f982f45f38226193cd584bbe7e93ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072d5393798650a838dc7f4b067f7232"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a072d5393798650a838dc7f4b067f7232">doPlacement</a> (std::ostream &amp;out_stream=std::cout)</td></tr>
<tr class="separator:a072d5393798650a838dc7f4b067f7232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9dfd1f20162021c5431ebe29d57ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a2c9dfd1f20162021c5431ebe29d57ef8">applySPR</a> (const <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43">TreeSearchType</a> tree_search_type, const bool shallow_tree_search, std::ostream &amp;out_stream=std::cout)</td></tr>
<tr class="separator:a2c9dfd1f20162021c5431ebe29d57ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc947148cb44b753d7799b4df5fa83f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#afc947148cb44b753d7799b4df5fa83f8">optimizeBranch</a> (std::ostream &amp;out_stream=std::cout)</td></tr>
<tr class="separator:afc947148cb44b753d7799b4df5fa83f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf42c58dd4db66c040386df9053f8ba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#aaf42c58dd4db66c040386df9053f8ba9">autoProceedMAPLE</a> (const <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43">TreeSearchType</a> tree_search_type=<a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43ad597e07c0182b56b0bc3d67b8fdaf0c1">NORMAL_TREE_SEARCH</a>, const bool shallow_tree_search=false, std::ostream &amp;out_stream=std::cout)</td></tr>
<tr class="memdesc:aaf42c58dd4db66c040386df9053f8ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer a phylogenetic tree by executing <a class="el" href="classcmaple_1_1_tree.html#a072d5393798650a838dc7f4b067f7232">doPlacement()</a>, <a class="el" href="classcmaple_1_1_tree.html#a2c9dfd1f20162021c5431ebe29d57ef8">applySPR()</a>, and <a class="el" href="classcmaple_1_1_tree.html#afc947148cb44b753d7799b4df5fa83f8">optimizeBranch()</a>  <br /></td></tr>
<tr class="separator:aaf42c58dd4db66c040386df9053f8ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987c92b41faa1303b5b0c8393c0704db"><td class="memItemLeft" align="right" valign="top">RealNumType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a987c92b41faa1303b5b0c8393c0704db">computeLh</a> ()</td></tr>
<tr class="memdesc:a987c92b41faa1303b5b0c8393c0704db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the log likelihood of the current tree, which may or may not contain all taxa in the alignment.  <br /></td></tr>
<tr class="separator:a987c92b41faa1303b5b0c8393c0704db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415d4e23f522c7ecb1f8363e27f6bafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a415d4e23f522c7ecb1f8363e27f6bafa">computeBranchSupport</a> (const int num_threads=1, const int num_replicates=1000, const double epsilon=0.1, const bool allow_replacing_ML_tree=true, std::ostream &amp;out_stream=std::cout)</td></tr>
<tr class="memdesc:a415d4e23f522c7ecb1f8363e27f6bafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute branch supports (<a href="https://academic.oup.com/sysbio/article/59/3/307/1702850">aLRT-SH</a>) of the current tree, which may or may not contain all taxa in the alignment.  <br /></td></tr>
<tr class="separator:a415d4e23f522c7ecb1f8363e27f6bafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1492f8a3291bd70af3a879b535f880"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcmaple_1_1_tree.html#a8d1492f8a3291bd70af3a879b535f880">exportNewick</a> (const <a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376">TreeType</a> tree_type=<a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376aed3efab1c9a9364074e767a772c132da">BIN_TREE</a>, const bool show_branch_supports=false)</td></tr>
<tr class="memdesc:a8d1492f8a3291bd70af3a879b535f880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the phylogenetic tree to a string in NEWICK format.  <br /></td></tr>
<tr class="separator:a8d1492f8a3291bd70af3a879b535f880"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The structure of a phylogenetic tree </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a39bd3bfce400c9222e8b77c584d26d43" name="a39bd3bfce400c9222e8b77c584d26d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bd3bfce400c9222e8b77c584d26d43">&#9670;&#160;</a></span>TreeSearchType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43">cmaple::Tree::TreeSearchType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Types of tree search </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a39bd3bfce400c9222e8b77c584d26d43a782a94a0336018d3a43f5e71e76e0bc6" name="a39bd3bfce400c9222e8b77c584d26d43a782a94a0336018d3a43f5e71e76e0bc6"></a>FAST_TREE_SEARCH&#160;</td><td class="fielddoc"><p>No tree search (placement only) </p>
</td></tr>
<tr><td class="fieldname"><a id="a39bd3bfce400c9222e8b77c584d26d43ad597e07c0182b56b0bc3d67b8fdaf0c1" name="a39bd3bfce400c9222e8b77c584d26d43ad597e07c0182b56b0bc3d67b8fdaf0c1"></a>NORMAL_TREE_SEARCH&#160;</td><td class="fielddoc"><p>Only consider pruning branches at newly-added nodes when seeking SPR moves </p>
</td></tr>
<tr><td class="fieldname"><a id="a39bd3bfce400c9222e8b77c584d26d43ae452d25b3b1a6060c8f156d0a35566d2" name="a39bd3bfce400c9222e8b77c584d26d43ae452d25b3b1a6060c8f156d0a35566d2"></a>MORE_ACCURATE_TREE_SEARCH&#160;</td><td class="fielddoc"><p>Consider all nodes when seeking SPR moves </p>
</td></tr>
<tr><td class="fieldname"><a id="a39bd3bfce400c9222e8b77c584d26d43a5c358c56b2d42131093b6b5386d1d8f5" name="a39bd3bfce400c9222e8b77c584d26d43a5c358c56b2d42131093b6b5386d1d8f5"></a>UNKNOWN_TREE_SEARCH&#160;</td><td class="fielddoc"><p>Unknown (not specified) </p>
</td></tr>
</table>

</div>
</div>
<a id="a750c5e7c53559fbcc421020bad665376" name="a750c5e7c53559fbcc421020bad665376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750c5e7c53559fbcc421020bad665376">&#9670;&#160;</a></span>TreeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376">cmaple::Tree::TreeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Types of trees </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a750c5e7c53559fbcc421020bad665376aed3efab1c9a9364074e767a772c132da" name="a750c5e7c53559fbcc421020bad665376aed3efab1c9a9364074e767a772c132da"></a>BIN_TREE&#160;</td><td class="fielddoc"><p>Binary tree </p>
</td></tr>
<tr><td class="fieldname"><a id="a750c5e7c53559fbcc421020bad665376a0156cc734ae126b57d1a6ceeb22bd9e9" name="a750c5e7c53559fbcc421020bad665376a0156cc734ae126b57d1a6ceeb22bd9e9"></a>MUL_TREE&#160;</td><td class="fielddoc"><p>Multifurcating tree </p>
</td></tr>
<tr><td class="fieldname"><a id="a750c5e7c53559fbcc421020bad665376af211a6a48af98121a51064677ec6d851" name="a750c5e7c53559fbcc421020bad665376af211a6a48af98121a51064677ec6d851"></a>UNKNOWN_TREE&#160;</td><td class="fielddoc"><p>Unknown tree type </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac8b9c0385a290c3d535434ae843338ce" name="ac8b9c0385a290c3d535434ae843338ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b9c0385a290c3d535434ae843338ce">&#9670;&#160;</a></span>Tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cmaple::Tree::Tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcmaple_1_1_alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcmaple_1_1_model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>tree_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fixed_blengths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; cmaple::Params &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor from a stream of a (bifurcating or multifurcating) tree (with/without branch lengths in NEWICK format), which may or may not contain all taxa in the alignment. <a class="el" href="classcmaple_1_1_model.html">Model</a> parameters (if not fixed) will be estimated according to the input tree and the alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aln</td><td>An alignment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>A substitution model </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_stream</td><td>A stream of an input tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_blengths</td><td>TRUE to keep the input branch lengths unchanged (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>an instance of Params which stores all program parameters (optional). Users can build an instance of Params and specify several parameters by using <a class="el" href="classcmaple_1_1_params_builder.html">ParamsBuilder</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If any of the following situation occurs.<ul>
<li>the sequence type is unsupported (neither DNA (for nucleotide data) nor AA (for protein data))</li>
<li>the alignment is empty</li>
<li>the model is unknown/unsupported</li>
<li>the tree is in an incorrect format</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>taxa in the tree (is specified) is not found in the alignment</li>
<li>unexpected values/behaviors found during the operations</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if failing to allocate memory to store the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af71b78fbf62c78e5630ac76f3fc319dc" name="af71b78fbf62c78e5630ac76f3fc319dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71b78fbf62c78e5630ac76f3fc319dc">&#9670;&#160;</a></span>Tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cmaple::Tree::Tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcmaple_1_1_alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcmaple_1_1_model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tree_filename</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fixed_blengths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; cmaple::Params &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor from an optional (bifurcating or multifurcating) tree (with/without branch lengths in NEWICK format), which may or may not contain all taxa in the alignment. If users specify an input tree, model parameters (if not fixed) will be estimated according to that tree and the alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aln</td><td>An alignment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>A substitution model </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_filename</td><td>Name of a tree file (optinal) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_blengths</td><td>TRUE to keep the input branch lengths unchanged (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>an instance of Params which stores all program parameters (optional). Users can build an instance of Params and specify several parameters by using <a class="el" href="classcmaple_1_1_params_builder.html">ParamsBuilder</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If any of the following situation occurs.<ul>
<li>the sequence type is unsupported (neither DNA (for nucleotide data) nor AA (for protein data))</li>
<li>the alignment is empty</li>
<li>the model is unknown/unsupported</li>
<li>the tree (is specified) but in an incorrect format</li>
</ul>
</td></tr>
    <tr><td class="paramname">ios::failure</td><td>if the tree file (is specified) is not found </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>taxa in the tree (is specified) is not found in the alignment</li>
<li>unexpected values/behaviors found during the operations</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if failing to allocate memory to store the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae05ee284fd0e9edba07708ec914eb045" name="ae05ee284fd0e9edba07708ec914eb045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05ee284fd0e9edba07708ec914eb045">&#9670;&#160;</a></span>~Tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cmaple::Tree::~Tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af8c288e5a4ae4277615cb24268dca2f2" name="af8c288e5a4ae4277615cb24268dca2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c288e5a4ae4277615cb24268dca2f2">&#9670;&#160;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>tree_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fixed_blengths</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a tree from a stream of a (bifurcating or multifurcating) tree (with/without branch lengths) in NEWICK format, which may or may not contain all taxa in the alignment. <a class="el" href="classcmaple_1_1_model.html">Model</a> parameters (if not fixed) will be estimated according to the input tree and the alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_stream</td><td>A stream of an input tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_blengths</td><td>TRUE to keep the input branch lengths unchanged (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if tree is empty or in an incorrect format </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the attached substitution model is unknown/unsupported</li>
<li>any taxa in the tree is not found in the alignment</li>
<li>unexpected values/behaviors found during the operations</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if failing to allocate memory to store the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b2479eb26d00469ee1040dd9bee18e5" name="a1b2479eb26d00469ee1040dd9bee18e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2479eb26d00469ee1040dd9bee18e5">&#9670;&#160;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tree_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fixed_blengths</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a tree from a (bifurcating or multifurcating) tree (with/without branch lengths) in NEWICK format, which may or may not contain all taxa in the alignment. <a class="el" href="classcmaple_1_1_model.html">Model</a> parameters (if not fixed) will be estimated according to the input tree and the alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_filename</td><td>Name of a tree file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_blengths</td><td>TRUE to keep the input branch lengths unchanged (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if tree is empty or in an incorrect format </td></tr>
    <tr><td class="paramname">ios::failure</td><td>if the tree file is not found </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the attached substitution model is unknown/unsupported</li>
<li>any taxa in the tree is not found in the alignment</li>
<li>unexpected values/behaviors found during the operations</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if failing to allocate memory to store the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab932b3742c6e18d51554f72432c18151" name="ab932b3742c6e18d51554f72432c18151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab932b3742c6e18d51554f72432c18151">&#9670;&#160;</a></span>changeAln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::changeAln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcmaple_1_1_alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aln</td><td>An alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the alignment is empty </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>taxa in the current tree is not found in the new alignment</li>
<li>the sequence type of the new alignment is different from the old one</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4f982f45f38226193cd584bbe7e93ef" name="aa4f982f45f38226193cd584bbe7e93ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f982f45f38226193cd584bbe7e93ef">&#9670;&#160;</a></span>changeModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::changeModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcmaple_1_1_model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the substitution model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>A substitution model </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the model is unknown/unsupported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the sequence type of the new model is different from the old one</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a072d5393798650a838dc7f4b067f7232" name="a072d5393798650a838dc7f4b067f7232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072d5393798650a838dc7f4b067f7232">&#9670;&#160;</a></span>doPlacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::doPlacement </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code>std::cout</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do placement (using stepwise addition) to build an initial tree. <a class="el" href="classcmaple_1_1_model.html">Model</a> parameters (if not fixed) will be estimated during the placement process.</p><ul>
<li>If users didn't supply an input tree or supplied an incomplete tree (which doesn't contain all the taxa in the alignment) when initializing the tree (by Tree() constructor), this function will add new taxa (which are not existed in the input tree) from the alignment to the tree.</li>
<li>If users already supplied a complete tree, this function does nothing.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_stream</td><td>the output message stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the attached substitution model is unknown/unsupported</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c9dfd1f20162021c5431ebe29d57ef8" name="a2c9dfd1f20162021c5431ebe29d57ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9dfd1f20162021c5431ebe29d57ef8">&#9670;&#160;</a></span>applySPR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::applySPR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43">TreeSearchType</a>&#160;</td>
          <td class="paramname"><em>tree_search_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shallow_tree_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply SPR moves to optimize the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_search_type</td><td>A type of tree search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shallow_tree_search</td><td>TRUE to enable a shallow tree search before a deeper tree search </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_stream</td><td>the output message stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the tree is empty</li>
<li>the attached substitution model is unknown/unsupported</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc947148cb44b753d7799b4df5fa83f8" name="afc947148cb44b753d7799b4df5fa83f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc947148cb44b753d7799b4df5fa83f8">&#9670;&#160;</a></span>optimizeBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::optimizeBranch </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code>std::cout</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize the branch lengths of the current tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_stream</td><td>the output message stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the tree is empty</li>
<li>the attached substitution model is unknown/unsupported</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf42c58dd4db66c040386df9053f8ba9" name="aaf42c58dd4db66c040386df9053f8ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf42c58dd4db66c040386df9053f8ba9">&#9670;&#160;</a></span>autoProceedMAPLE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::autoProceedMAPLE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43">TreeSearchType</a>&#160;</td>
          <td class="paramname"><em>tree_search_type</em> = <code><a class="el" href="classcmaple_1_1_tree.html#a39bd3bfce400c9222e8b77c584d26d43ad597e07c0182b56b0bc3d67b8fdaf0c1">NORMAL_TREE_SEARCH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shallow_tree_search</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer a phylogenetic tree by executing <a class="el" href="classcmaple_1_1_tree.html#a072d5393798650a838dc7f4b067f7232">doPlacement()</a>, <a class="el" href="classcmaple_1_1_tree.html#a2c9dfd1f20162021c5431ebe29d57ef8">applySPR()</a>, and <a class="el" href="classcmaple_1_1_tree.html#afc947148cb44b753d7799b4df5fa83f8">optimizeBranch()</a> </p>
<ul>
<li>If users didn't supply an input tree or supplied an incomplete tree (which doesn't contain all the taxa in the alignment) when initializing the tree (by Tree() constructor), this function:<ul>
<li>performs placement (i.e., adding missing taxa from the alignment to the tree)</li>
<li>applies a NORMAL tree search (which does SPR moves only on newly-added nodes)</li>
<li>optimizes all branch lengths</li>
</ul>
</li>
<li>If users already supplied a complete tree, this function, by default, does neither placment nor tree search, but it optimizes all branch lengths. If users want to keep the branch lengths fixed, they should set fixed_blengths = true when initializing the tree (by Tree() constructor);</li>
<li>If users want to use the input (complete/incomplete) tree as a starting tree to perform placement (for an incomplete tree), then consider SPR moves on all nodes, and optimize branch lengths, they should set tree_search_type = MORE_ACCURATE</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_search_type</td><td>A type of tree search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shallow_tree_search</td><td>TRUE to enable a shallow tree search before a deeper tree search </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_stream</td><td>the output message stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if tree_search_type is unknown </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the attached substitution model is unknown/unsupported</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a987c92b41faa1303b5b0c8393c0704db" name="a987c92b41faa1303b5b0c8393c0704db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987c92b41faa1303b5b0c8393c0704db">&#9670;&#160;</a></span>computeLh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RealNumType cmaple::Tree::computeLh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the log likelihood of the current tree, which may or may not contain all taxa in the alignment. </p>
<dl class="section return"><dt>Returns</dt><dd>The log likelihood of the current tree </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the tree is empty</li>
<li>the attached substitution model is unknown/unsupported</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415d4e23f522c7ecb1f8363e27f6bafa" name="a415d4e23f522c7ecb1f8363e27f6bafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415d4e23f522c7ecb1f8363e27f6bafa">&#9670;&#160;</a></span>computeBranchSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmaple::Tree::computeBranchSupport </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_replicates</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_replacing_ML_tree</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute branch supports (<a href="https://academic.oup.com/sysbio/article/59/3/307/1702850">aLRT-SH</a>) of the current tree, which may or may not contain all taxa in the alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_threads</td><td>The number of threads (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_replicates</td><td>A positive number of replicates (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>A positive epsilon (optional), which is used to avoid rounding effects, when the best and second best NNI trees have nearly identical site log-likelihood values (see <a href="https://academic.oup.com/sysbio/article/59/3/307/1702850">Guindon et al., 2010</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_replacing_ML_tree</td><td>TRUE to allow replacing the ML tree by a higher likelihood tree found when computing branch supports (optional) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_stream</td><td>the output message stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if any of the following situations occur.<ul>
<li>num_threads &lt; 0 or num_threads &gt; the number of CPU cores</li>
<li>num_replicates &lt;= 0</li>
<li>epsilon &lt; 0</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if any of the following situations occur.<ul>
<li>the tree is empty</li>
<li>the attached substitution model is unknown/unsupported</li>
<li>unexpected values/behaviors found during the operations </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d1492f8a3291bd70af3a879b535f880" name="a8d1492f8a3291bd70af3a879b535f880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1492f8a3291bd70af3a879b535f880">&#9670;&#160;</a></span>exportNewick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cmaple::Tree::exportNewick </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376">TreeType</a>&#160;</td>
          <td class="paramname"><em>tree_type</em> = <code><a class="el" href="classcmaple_1_1_tree.html#a750c5e7c53559fbcc421020bad665376aed3efab1c9a9364074e767a772c132da">BIN_TREE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>show_branch_supports</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the phylogenetic tree to a string in NEWICK format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_type</td><td>The type of the output tree (optional): BIN_TREE (bifurcating tree), MUL_TREE (multifurcating tree) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">show_branch_supports</td><td>TRUE to output the branch supports (aLRT-SH values) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tree string in NEWICK format </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if any of the following situations occur.<ul>
<li>n_tree_type is unknown</li>
<li>show_branch_supports = true but branch support values have yet been computed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tree/<a class="el" href="tree_8h_source.html">tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
